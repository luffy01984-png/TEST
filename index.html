<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no"/>
<title>Doodle Jump â€” Custom (fullscreen mobile)</title>
<style>
  :root{
    --ui-bg: rgba(255,255,255,0.85);
    --accent: #ff6f61;
    --text: #222;
  }
  html,body{
    margin:0; padding:0; height:100%; width:100%;
    background: linear-gradient(#bfe9ff,#8ecfff 60%, #7fc7ff);
    font-family: Inter, system-ui, Arial, sans-serif;
    -webkit-tap-highlight-color: transparent;
    overflow: hidden;
  }

  canvas{
    display:block;
    position:fixed;
    inset:0;
    width:100vw;
    height:100vh;
    touch-action: none;
    background: linear-gradient(#bdf,#8cf);
  }

  .hud{
    position:fixed;
    left:12px; right:12px;
    top:12px;
    display:flex;
    justify-content:space-between;
    align-items:center;
    pointer-events:none;
    gap:8px;
  }
  .panel{
    background: var(--ui-bg);
    padding:8px 12px;
    border-radius:12px;
    box-shadow: 0 6px 18px rgba(0,0,0,0.08);
    font-weight:600;
    color:var(--text);
    pointer-events:auto;
  }
  .controls{
    position:fixed;
    bottom:18px;
    left:0; right:0;
    display:flex;
    justify-content:center;
    gap:12px;
    pointer-events:none;
  }
  .btn{
    pointer-events:auto;
    background:white;
    border:1px solid #eee;
    padding:10px 14px;
    border-radius:12px;
    font-size:16px;
    cursor:pointer;
  }
  .small{
    font-size:12px; color:#444; opacity:0.9;
  }
  /* virtual left/right big hit areas (invisible) */
  .touch-left, .touch-right{
    position:fixed; bottom:0; top:0; width:50vw; z-index:2;
    pointer-events:auto;
  }
  .touch-left{ left:0; }
  .touch-right{ right:0; }
  .fs-btn{ background:var(--accent); color:white; border:none; }
</style>
</head>
<body>
<canvas id="c"></canvas>

<div class="hud">
  <div class="panel" id="scorePanel">Score: 0</div>
  <div style="display:flex;gap:8px;">
    <button class="btn" id="soundBtn">ðŸ”Š</button>
    <button class="btn fs-btn" id="fsBtn">Plein Ã©cran</button>
  </div>
</div>

<div class="controls">
  <button class="btn" id="startBtn">Jouer</button>
  <button class="btn" id="restartBtn">Recommencer</button>
</div>

<!-- Invisible full-height touch areas for left/right control -->
<div class="touch-left" id="touchLeft"></div>
<div class="touch-right" id="touchRight"></div>

<script>
/* ----------------------------
   Doodle Jump Like â€” All In One
   ----------------------------
   - Uses your transparent PNG (raw GitHub URL)
   - Mobile-friendly fullscreen + touch controls
   - Platforms: normal, moving, breakable, trampoline, jet
   - Ennemis, coins, sounds, player animation
   - Score + highscore saved in localStorage
*/

/* ---------- CONFIG ---------- */
const PLAYER_IMG_URL = 'https://raw.githubusercontent.com/luffy01984-png/TEST/main/chris.jpg'; // your image (transparent)
const LOGICAL_W = 720;            // base logical width
const LOGICAL_H = 1280;           // base logical height for scaling
const GRAVITY = 0.45;
const START_VY = -11.5;           // initial jump when hitting a platform
const PLATFORM_COUNT = 9;
const PLAYER_BASE_W = 110;        // enlarged player width
const PLAYER_BASE_H = 110;        // enlarged player height
const PLATFORM_TYPES = ['normal','moving','fragile','spring','jet'];

/* ---------- CANVAS & SCALE ---------- */
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d', { alpha: false });

let DPR = Math.max(1, Math.floor(window.devicePixelRatio || 1));
function resizeCanvas(){
  DPR = Math.max(1, Math.floor(window.devicePixelRatio || 1));
  canvas.width = Math.floor(window.innerWidth * DPR);
  canvas.height = Math.floor(window.innerHeight * DPR);
  canvas.style.width = window.innerWidth + 'px';
  canvas.style.height = window.innerHeight + 'px';
  ctx.setTransform(DPR,0,0,DPR,0,0);
  scaleX = canvas.width/DPR / LOGICAL_W;
  scaleY = canvas.height/DPR / LOGICAL_H;
  scale = Math.min(scaleX, scaleY); // keep aspect and scale
}
let scale = 1, scaleX=1, scaleY=1;
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

/* ---------- GAME STATE ---------- */
let running = false;
let score = 0;
let highScore = parseInt(localStorage.getItem('doodle_highscore')||'0',10);
let lastTime = 0;
let platforms = [];
let enemies = [];
let coins = [];
let particles = [];
let camY = 0; // camera offset (we scroll upwards)
let soundOn = true;

/* ---------- LOAD PLAYER IMAGE ---------- */
const playerImg = new Image();
playerImg.crossOrigin = 'anonymous';
playerImg.src = PLAYER_IMG_URL;
let playerImgReady = false;
playerImg.onload = () => { playerImgReady = true; };

/* ---------- AUDIO (simple WebAudio events) ---------- */
let audioCtx = null;
function ensureAudio(){
  if(!audioCtx){
    try{ audioCtx = new (window.AudioContext||window.webkitAudioContext)(); }catch(e){ audioCtx = null; }
  }
}
function playTone(freq=440, time=0.08, type='sine', vol=0.15){
  if(!soundOn) return;
  ensureAudio();
  if(!audioCtx) return;
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = type; o.frequency.value = freq;
  g.gain.value = vol;
  o.connect(g); g.connect(audioCtx.destination);
  o.start();
  o.stop(audioCtx.currentTime + time);
}
function playJump(){ playTone(880,0.06,'sine',0.12); }
function playSpring(){ playTone(1200,0.08,'square',0.16); }
function playCoin(){ playTone(1200,0.04,'sine',0.14); }
function playGameOver(){ playTone(200,0.3,'sawtooth',0.22); }

/* ---------- ENTITY: PLAYER ---------- */
const player = {
  x: LOGICAL_W/2 - PLAYER_BASE_W/2,
  y: LOGICAL_H - 300,
  w: PLAYER_BASE_W,
  h: PLAYER_BASE_H,
  vy: 0,
  vx: 0,
  rotation: 0,
  onPlatform: false,
  animTick: 0, // for subtle bob
  update(dt){
    // gravity
    this.vy += GRAVITY * dt;
    this.y += this.vy * dt;
    // horizontal friction & velocity
    this.x += this.vx * dt;
    this.vx *= 0.98;

    // world wrap horizontally
    if(this.x < -this.w) this.x = LOGICAL_W;
    if(this.x > LOGICAL_W) this.x = -this.w;

    // animation small tilt based on vy
    this.rotation = Math.max(-0.35, Math.min(0.35, -this.vy/40));
    this.animTick += 0.05 * dt;
  },
  draw(){
    ctx.save();
    ctx.translate(this.x + this.w/2, this.y + this.h/2);
    ctx.rotate(this.rotation);
    const drawW = this.w;
    const drawH = this.h;
    ctx.translate(-drawW/2, -drawH/2);
    if(playerImgReady){
      ctx.drawImage(playerImg, 0, 0, drawW, drawH);
    } else {
      // fallback placeholder
      ctx.fillStyle = '#26a';
      roundRect(ctx, 0, 0, drawW, drawH, 14);
    }
    ctx.restore();
  },
  box(){
    return {x:this.x, y:this.y, w:this.w, h:this.h};
  }
};

/* ---------- UTIL ---------- */
function rnd(a,b){ return a + Math.random()*(b-a); }
function randInt(a,b){ return Math.floor(a + Math.random()*(b-a+1)); }
function roundRect(ctx,x,y,w,h,r){
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.arcTo(x+w,y,x+w,y+h,r);
  ctx.arcTo(x+w,y+h,x,y+h,r);
  ctx.arcTo(x,y+h,x,y,r);
  ctx.arcTo(x,y,x+w,y,r);
  ctx.closePath();
  ctx.fill();
}

/* ---------- PLATFORMS ---------- */
function spawnInitialPlatforms(){
  platforms = [];
  const gap = LOGICAL_H / PLATFORM_COUNT;
  for(let i=0;i<PLATFORM_COUNT;i++){
    let px = rnd(30, LOGICAL_W - 150);
    let py = LOGICAL_H - i * gap - 80;
    const typeRoll = Math.random();
    let type = 'normal';
    if(typeRoll > 0.92) type = 'jet';
    else if(typeRoll > 0.82) type = 'spring';
    else if(typeRoll > 0.68) type = 'fragile';
    else if(typeRoll > 0.5) type = 'moving';
    platforms.push(createPlatform(px,py,type));
  }
}

function createPlatform(x,y,type='normal'){
  const p = { x, y, w: rnd(90,140), h: 18, type, vx:0, alive:true };
  if(type === 'moving') p.vx = rnd(0.6,1.8) * (Math.random()>0.5?1:-1);
  return p;
}

/* ---------- ENEMIES ---------- */
function maybeSpawnEnemy(){
  // spawn by chance above camera
  if(Math.random() < 0.02){
    const ex = rnd(30, LOGICAL_W-80);
    const ey = camY - rnd(200,700);
    enemies.push({ x:ex, y:ey, w:72, h:72, vx: rnd(1,2)*(Math.random()>0.5?1:-1) });
  }
}

/* ---------- COINS ---------- */
function maybeSpawnCoin(){
  if(Math.random() < 0.06){
    const cx = rnd(40, LOGICAL_W-40);
    const cy = camY - rnd(100,900);
    coins.push({ x:cx, y:cy, r:12, collected:false });
  }
}

/* ---------- PARTICLES (for effects) ---------- */
function spawnParticles(x,y,color, n=10){
  for(let i=0;i<n;i++){
    particles.push({
      x, y,
      vx: rnd(-3,3),
      vy: rnd(-5,1),
      life: rnd(18,40),
      col: color
    });
  }
}

/* ---------- COLLISION ---------- */
function rectsOverlap(a,b){
  return !(a.x + a.w < b.x || a.x > b.x + b.w || a.y + a.h < b.y || a.y > b.y + b.h);
}

/* ---------- GAME UPDATE ---------- */
function update(dtRaw){
  const dt = Math.min(2, dtRaw/16.666); // normalized
  // update player physics
  player.update(dt * 1.0);

  // camera: if player rises above half screen, scroll up
  const screenMid = LOGICAL_H * 0.45;
  if(player.y < camY + screenMid){
    const delta = (camY + screenMid) - player.y;
    camY -= delta;
    score += Math.floor(delta * 0.4);
  }

  // update platforms
  for(let p of platforms){
    if(!p.alive) continue;
    if(p.type === 'moving'){
      p.x += p.vx * dt * 20;
      if(p.x < 10) p.x = 10, p.vx *= -1;
      if(p.x + p.w > LOGICAL_W-10) p.x = LOGICAL_W - 10 - p.w, p.vx *= -1;
    }
  }

  // player collision with platforms (only while falling)
  if(player.vy > 0){
    for(let p of platforms){
      if(!p.alive) continue;
      // check that player is above the platform and will cross it
      if(player.x + player.w > p.x && player.x < p.x + p.w){
        const py = p.y;
        if((player.y + player.h) <= py + 12 && (player.y + player.h + player.vy*dt) >= py){
          // landing
          if(p.type === 'fragile'){
            // break, no bounce on first landing - bounce but remove
            player.vy = START_VY * 0.95;
            p.alive = false;
            spawnParticles(player.x + player.w/2, py, '#b5651d', 14);
            playJump();
          } else if(p.type === 'spring'){
            player.vy = -18;
            playSpring();
            spawnParticles(player.x + player.w/2, py, '#ff0', 10);
          } else if(p.type === 'jet'){
            player.vy = -26; // strong boost
            playSpring();
            spawnParticles(player.x + player.w/2, py, '#7ff', 18);
          } else {
            // normal bounce
            player.vy = START_VY;
            playJump();
            spawnParticles(player.x + player.w/2, py, '#fff', 8);
          }
        }
      }
    }
  }

  // enemies movement & collision
  for(let e of enemies){
    e.x += e.vx * dt * 20;
    if(e.x < 10 || e.x + e.w > LOGICAL_W - 10) e.vx *= -1;
    // collision with player (if player hits enemy from above while falling -> stomp)
    if(rectsOverlap(player.box(), e)){
      const stompZone = player.y + player.h - 12;
      if(player.vy > 0 && stompZone <= e.y + 14){
        // stomp enemy
        playCoin();
        score += 250;
        spawnParticles(e.x + e.w/2, e.y + e.h/2, '#f66', 18);
        // remove enemy
        e.dead = true;
        player.vy = START_VY * 0.9; // small bounce
      } else {
        // player hit -> game over
        gameOver();
      }
    }
  }
  enemies = enemies.filter(e => !e.dead);

  // coins collection
  for(let c of coins){
    if(!c.collected && player.x + player.w > c.x - c.r && player.x < c.x + c.r && player.y + player.h > c.y - c.r && player.y < c.y + c.r){
      c.collected = true;
      playCoin();
      score += 100;
      spawnParticles(c.x, c.y, '#ffd700', 12);
    }
  }
  coins = coins.filter(c => !c.collected && c.y - camY < LOGICAL_H + 200);

  // particles update
  for(let i=particles.length-1;i>=0;i--){
    const p = particles[i];
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.vy += 0.25 * dt;
    p.life -= 1 * dt;
    if(p.life <= 0) particles.splice(i,1);
  }

  // spawn more platforms above as camera rises
  while(platforms.length < PLATFORM_COUNT){
    const px = rnd(20, LOGICAL_W - 140);
    const py = camY - rnd(60, 180);
    const rr = Math.random();
    let type = 'normal';
    if(rr > 0.96) type = 'jet';
    else if(rr > 0.88) type = 'spring';
    else if(rr > 0.78) type = 'fragile';
    else if(rr > 0.54) type = 'moving';
    platforms.push(createPlatform(px, py, type));
  }

  // occasionally spawn enemies/coins
  maybeSpawnEnemy();
  maybeSpawnCoin();

  // remove platforms below screen
  platforms = platforms.filter(p => p.y - camY < LOGICAL_H + 160 && (p.alive!==false));

  // game over if player falls too far below camera
  if(player.y - camY > LOGICAL_H + 300){
    gameOver();
  }
}

/* ---------- DRAW ---------- */
function draw(){
  // clear (we draw in logical space scaled by scale)
  ctx.save();
  ctx.clearRect(0,0,canvas.width/DPR, canvas.height/DPR);

  // background gradient & parallax clouds
  const vw = LOGICAL_W;
  const vh = LOGICAL_H;
  // sky (we already have CSS gradient for canvas but redraw background for logical coords)
  const skyG = ctx.createLinearGradient(0,0,0, vh);
  skyG.addColorStop(0,'#bdf');
  skyG.addColorStop(1,'#8cf');
  ctx.fillStyle = skyG;
  ctx.fillRect(0,0, vw, vh);

  // parallax clouds (based on camY)
  const cloudCount = 8;
  ctx.globalAlpha = 0.95;
  for(let i=0;i<cloudCount;i++){
    const cx = ((i*97) * 0.7 + (camY*0.1)) % (vw + 200) - 100;
    const cy = (i*76 % vh) * 0.4 + 60 + (i*15 % 120);
    roundRect(ctx, cx, (cy - camY*0.02)%vh, 160, 34, 40);
  }
  ctx.globalAlpha = 1;

  // translate camera (we draw everything relative to camY)
  ctx.save();
  ctx.translate(0, -camY);

  // draw platforms
  for(let p of platforms){
    ctx.save();
    if(p.type === 'normal'){
      ctx.fillStyle = '#6ab04c';
      roundRect(ctx, p.x, p.y, p.w, p.h, 8);
    } else if(p.type === 'moving'){
      ctx.fillStyle = '#3b8';
      roundRect(ctx, p.x, p.y, p.w, p.h, 8);
    } else if(p.type === 'fragile'){
      ctx.fillStyle = '#c96';
      roundRect(ctx, p.x, p.y, p.w, p.h, 8);
      ctx.fillStyle = 'rgba(255,255,255,0.06)';
      ctx.fillRect(p.x+6, p.y+4, p.w-12, p.h-8);
    } else if(p.type === 'spring'){
      ctx.fillStyle = '#ffdf5a';
      roundRect(ctx, p.x, p.y, p.w, p.h, 8);
      // spring icon
      ctx.fillStyle = '#c59a00';
      ctx.fillRect(p.x + p.w/2 - 8, p.y + 2, 16, p.h-4);
    } else if(p.type === 'jet'){
      ctx.fillStyle = '#7ff';
      roundRect(ctx, p.x, p.y, p.w, p.h, 8);
      ctx.fillStyle = '#06c';
      ctx.fillRect(p.x + p.w/2 - 14, p.y + 2, 28, p.h-4);
    }
    ctx.restore();
  }

  // enemies
  for(let e of enemies){
    ctx.save();
    // simple creature: circle + eyes
    ctx.fillStyle = '#b33';
    roundRect(ctx, e.x, e.y, e.w, e.h, 18);
    ctx.fillStyle = '#fff';
    ctx.fillRect(e.x + e.w*0.2, e.y + e.h*0.25, e.w*0.18, e.h*0.18);
    ctx.fillRect(e.x + e.w*0.6, e.y + e.h*0.25, e.w*0.18, e.h*0.18);
    ctx.fillStyle = '#000';
    ctx.fillRect(e.x + e.w*0.24, e.y + e.h*0.3, 6, 6);
    ctx.fillRect(e.x + e.w*0.65, e.y + e.h*0.3, 6, 6);
    ctx.restore();
  }

  // coins
  for(let c of coins){
    ctx.save();
    ctx.fillStyle = '#ffd700';
    ctx.beginPath();
    ctx.arc(c.x, c.y, c.r, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  // particles
  for(let p of particles){
    ctx.fillStyle = p.col;
    ctx.fillRect(p.x-2, p.y-2, 4, 4);
  }

  // player
  player.draw();

  ctx.restore(); // end camera translate

  // HUD overlay (score)
  ctx.fillStyle = 'rgba(255,255,255,0.85)';
  ctx.font = '20px system-ui';
  // We'll keep DOM HUD updated separately
  ctx.restore();
}

/* ---------- GAME LOOP ---------- */
function tick(ts){
  if(!lastTime) lastTime = ts;
  const dt = ts - lastTime;
  lastTime = ts;
  if(running){
    update(dt);
    draw();
    // update DOM score
    document.getElementById('scorePanel').textContent = `Score: ${score}  â€¢  High: ${highScore}`;
  } else {
    // draw once to show paused state
    draw();
  }
  requestAnimationFrame(tick);
}

/* ---------- GAME CONTROL ---------- */
function startGame(){
  running = true;
  score = 0;
  camY = 0;
  player.x = LOGICAL_W/2 - player.w/2;
  player.y = LOGICAL_H - 300;
  player.vy = -4;
  enemies = [];
  coins = [];
  particles = [];
  spawnInitialPlatforms();
  lastTime = 0;
}
function restartGame(){
  startGame();
}
function gameOver(){
  if(!running) return;
  running = false;
  playGameOver();
  if(score > highScore){
    highScore = score;
    localStorage.setItem('doodle_highscore', highScore);
  }
  // show button highlight (simple)
  navigator.vibrate && navigator.vibrate(120);
}

/* ---------- INPUT HANDLING ---------- */
let leftDown = false, rightDown = false;
function applyControls(){
  // smooth acceleration
  if(leftDown) player.vx = Math.max(player.vx - 1.0, -12);
  if(rightDown) player.vx = Math.min(player.vx + 1.0, 12);
}
setInterval(applyControls, 16);

document.getElementById('startBtn').addEventListener('click', () => {
  startGame();
});
document.getElementById('restartBtn').addEventListener('click', () => {
  restartGame();
});
document.getElementById('soundBtn').addEventListener('click', () => {
  soundOn = !soundOn;
  document.getElementById('soundBtn').textContent = soundOn ? 'ðŸ”Š' : 'ðŸ”‡';
  if(soundOn) ensureAudio();
});

// fullscreen
document.getElementById('fsBtn').addEventListener('click', async () => {
  try {
    if(!document.fullscreenElement) await document.documentElement.requestFullscreen();
    else await document.exitFullscreen();
  }catch(e){}
});

// keyboard
window.addEventListener('keydown', (e) => {
  if(e.code === 'ArrowLeft' || e.code === 'KeyA') leftDown = true;
  if(e.code === 'ArrowRight' || e.code === 'KeyD') rightDown = true;
  if(e.code === 'Space') {
    // small jump if on platform
    player.vy = -12;
  }
});
window.addEventListener('keyup', (e) => {
  if(e.code === 'ArrowLeft' || e.code === 'KeyA') leftDown = false;
  if(e.code === 'ArrowRight' || e.code === 'KeyD') rightDown = false;
});

// touch areas
const touchLeft = document.getElementById('touchLeft');
const touchRight = document.getElementById('touchRight');

function touchStartLeft(){ leftDown = true; }
function touchEndLeft(){ leftDown = false; }
function touchStartRight(){ rightDown = true; }
function touchEndRight(){ rightDown = false; }

touchLeft.addEventListener('touchstart', (e)=>{ e.preventDefault(); touchStartLeft(); });
touchLeft.addEventListener('touchend', (e)=>{ e.preventDefault(); touchEndLeft(); });
touchLeft.addEventListener('touchcancel', touchEndLeft);

touchRight.addEventListener('touchstart', (e)=>{ e.preventDefault(); touchStartRight(); });
touchRight.addEventListener('touchend', (e)=>{ e.preventDefault(); touchEndRight(); });
touchRight.addEventListener('touchcancel', touchEndRight);

// single tap to nudge or start
canvas.addEventListener('touchstart', (e) => {
  e.preventDefault();
  if(!running) startGame();
  // allow tap to jump a bit (nudge)
  if(player.vy > 0) player.vy = -8;
});

// mouse click support
canvas.addEventListener('mousedown', (e) => {
  if(!running) startGame();
  if(e.clientX < window.innerWidth/2) leftDown = true; else rightDown = true;
});
canvas.addEventListener('mouseup', ()=>{ leftDown=false; rightDown=false; });

/* ---------- INIT ---------- */
spawnInitialPlatforms();
tick();

</script>

</body>
</html>
